// GitHub PR Agent - Automatically creates pull requests

const { Octokit } = require('@octokit/rest');

class GitHubPRAgent {
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN
    });
    this.owner = process.env.GITHUB_REPO_OWNER;
    this.repo = process.env.GITHUB_REPO_NAME;
  }

  async createPR(incident) {
    if (!process.env.GITHUB_TOKEN) {
      console.log('âš ï¸  GitHub token not configured - PR creation skipped');
      return {
        skipped: true,
        reason: 'No GitHub token configured'
      };
    }

    await new Promise(resolve => setTimeout(resolve, 800));

    try {
      const branchName = `autoops/fix-${incident.id}`;
      const prTitle = `ðŸ¤– [AutoOps] Fix: ${incident.anomaly.summary}`;
      
      // For demo, we return mock PR data
      // In production, this would call the real GitHub API
      const mockPR = {
        number: Math.floor(Math.random() * 1000) + 1,
        html_url: `https://github.com/${this.owner}/${this.repo}/pull/${Math.floor(Math.random() * 1000) + 1}`,
        title: prTitle,
        branch: branchName,
        state: 'open',
        created_at: new Date().toISOString()
      };

      console.log(`\n  ðŸ“ Pull Request Created:`);
      console.log(`     PR #${mockPR.number}: ${mockPR.title}`);
      console.log(`     Branch: ${branchName}`);
      console.log(`     URL: ${mockPR.html_url}`);

      return {
        created: true,
        pr: mockPR,
        filesChanged: incident.proposedFix.files.length,
        tokens: { input: 100, output: 50 }
      };

    } catch (error) {
      console.error('Failed to create PR:', error.message);
      return {
        created: false,
        error: error.message,
        tokens: { input: 50, output: 20 }
      };
    }
  }

  generatePRBody(incident) {
    return `## ðŸ¤– AutoOps AI - Automated Fix

### ðŸš¨ Incident Summary
**ID:** ${incident.id}  
**Severity:** ${incident.anomaly.severity.toUpperCase()}  
**Service:** ${incident.anomaly.affectedService}  
**Detected:** ${incident.timestamp}  
**Impact:** ~${incident.anomaly.impactedUsers.toLocaleString()} users affected

---

### ðŸ§  Root Cause Analysis
${incident.rootCause.primaryRootCause}

**Confidence:** ${incident.rootCause.probability}%  
**Blast Radius:** ${incident.rootCause.blastRadius}

---

### ðŸ”§ Changes Made
${incident.proposedFix.files.map(f => `- \`${f.path}\` (${f.action})`).join('\n')}

---

### ðŸ“‹ Deployment Plan
${incident.proposedFix.deploymentSteps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

---

### ðŸ”„ Rollback Plan
${incident.proposedFix.rollbackPlan}

---

### ðŸ”’ Security Validation
**Status:** ${incident.securityReport.approved ? 'âœ… PASSED' : 'âŒ FAILED'}  
**Risk Level:** ${incident.securityReport.riskLevel}  
${incident.securityReport.vulnerabilities.length > 0 ? `\n**Vulnerabilities Found:**\n${incident.securityReport.vulnerabilities.map(v => `- ${v.issue} (${v.severity})`).join('\n')}` : ''}

---

### ðŸ“Š Metrics
**Processing Time:** ${incident.processingTime}ms  
**AI Cost:** $${this.calculateCost(incident)}  
**Agents Involved:** Monitor â†’ Log Analyzer â†’ Root Cause â†’ Fix Generator â†’ Security Scanner

---

### âœ… Pre-Merge Checklist
- [ ] Review code changes
- [ ] Run integration tests
- [ ] Deploy to staging first
- [ ] Monitor for 30 minutes
- [ ] Deploy to production

---

*ðŸ¤– This PR was automatically generated by AutoOps AI*  
*ðŸ’¡ Review carefully before merging*
`;
  }

  calculateCost(incident) {
    let total = 0;
    ['anomaly', 'logAnalysis', 'rootCause', 'proposedFix', 'securityReport'].forEach(key => {
      if (incident[key] && incident[key].tokens) {
        const tokens = incident[key].tokens;
        total += (tokens.input / 1000000) * 3 + (tokens.output / 1000000) * 15;
      }
    });
    return total.toFixed(6);
  }
}

module.exports = GitHubPRAgent;